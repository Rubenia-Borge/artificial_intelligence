# -*- coding: utf-8 -*-
"""bfs1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c0LxccWWsAcwRh5NBATfl4oTdm29rgvq
"""

graph = {'A': ['B', 'C', 'E'],
         'B': ['A','D', 'E'],
         'C': ['A', 'F', 'G'],
         'D': ['B'],
         'E': ['A', 'B','D'],
         'F': ['C'],
         'G': ['C']}

def bfs_connected_component(graph, start):
    explored = []   
    queue = [start]

def bfs_connected_component(graph, start):    
    explored = []    
    queue = [start]    
    while queue:       
        node = queue.pop(0)
        if node not in explored:            
            explored.append(node)
            neighbours = graph[node]           
            for neighbour in neighbours:
                queue.append(neighbour)
    return explored
 
bfs_connected_component(graph,'A') # returns ['A', 'B', 'C', 'E', 'D', 'F', 'G']

def bfs_shortest_path(graph, start, goal):
    explored = []
    queue = [[start]]
    
    if start == goal:
        return "That was easy! Start = goal"
 
    while queue:
        path = queue.pop(0)
        node = path[-1]
        if node not in explored:
            neighbours = graph[node]
            for neighbour in neighbours:
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)
                if neighbour == goal:
                    return new_path
 
            explored.append(node)
 
    return "connecting path doesn't exist"
 
bfs_shortest_path(graph, 'G', 'D')